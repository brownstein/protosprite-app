import { app, BrowserWindow, dialog, ipcMain } from "electron";
import { readFile, writeFileSync } from "fs";
import path from "path";
import { importAseprite } from "./backend/aseprite";
import { ProtoSpriteSheet } from "protosprite-core";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

let mainWindow: BrowserWindow | undefined;

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 960,
    width: 1024,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  app.quit();
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// Handle loading.

ipcMain.on(
  "load-file",
  async () => {
    if (!mainWindow) return;
    const openDialogVal = await dialog.showOpenDialog(mainWindow, {
      title: "Load File",
      filters: [
        {
          name: "All compatible files",
          extensions: [".ase", ".aseprite", ".prs"]
        },
        {
          name: "Aseprite",
          extensions: [".ase", ".aseprite"]
        },
        {
          name: "Protosprite",
          extensions: [".prs"]
        }
      ]
    });
    openDialogVal.filePaths.forEach(readAnyFile);
  }
);

ipcMain.on(
  "files-dropped",
  (
    _msg,
    data: {
      fileNames: string[];
    },
  ) => {
    for (const fileName of data.fileNames) {
      if (!fileName.length) continue;
      readAnyFile(fileName);
    }
  },
);

let workingFiles: string[];

function readAnyFile(fileName: string) {
  const pathParts = path.parse(fileName);
  switch (pathParts.ext) {
    case ".prs":
      console.log("Found protosprite file:", pathParts.base);
      return readProtospriteFile(fileName);
    case ".ase":
    case ".aseprite":
      console.log("Found aseprite file:", pathParts.base);
      return readAsepriteFile(fileName);
    default:
      console.log("Found unknown file:", pathParts.base, ", discarding..");
      return;
  }
}

function readProtospriteFile(fileName: string) {
  const pathParts = path.parse(fileName);
  readFile(fileName, (err, data) => {
    if (err) {
      console.error("Failed to read protosprite file", err);
      return;
    }
    workingFiles = [fileName];
    mainWindow?.webContents.send("file-loaded", {
      nativePath: fileName,
      mimeType: "image/protosprite",
      data: new Uint8Array(data),
    });
    mainWindow?.setTitle(pathParts.base);
  });
}

async function readAsepriteFile(fileName: string) {
  const spriteSheetData = await importAseprite(fileName);
  if (!spriteSheetData) return;
  const sheet = new ProtoSpriteSheet(spriteSheetData);
  const serializedSheet = sheet.toArray();
  workingFiles = [fileName];
  mainWindow?.webContents.send("file-loaded", {
    nativePath: fileName,
    mimeType: "image/aseprite",
    data: serializedSheet,
  });
}

// Handle saving.
ipcMain.on("save-file", async (
  _msg,
  data: {
    fileName: string,
    fileContents: Uint8Array
  }
) => {
  if (!mainWindow) return;
  const saveDialogVal = await dialog.showSaveDialog(mainWindow, {
    title: "Save File",
    defaultPath: workingFiles.find((f => f.endsWith(".prs"))),
    filters: [{
      name: "Protosprite Files",
      extensions: [".prs"] 
    }]
  });
  const filePath = saveDialogVal.filePath;
  writeFileSync(filePath, data.fileContents, { encoding: "binary" });
});

// Handle the browser window informing us that things have loaded. Re-read files.
// This fixes an issue where hot-reloading on the frontend killed the application state.
ipcMain.on("reload", () => {
  workingFiles?.forEach(readAnyFile);
});
